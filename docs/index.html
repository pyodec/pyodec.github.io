<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Pyodec Open file decoder</title>

    <!-- Bootstrap -->
    <link href="/bs/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/scroll.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
    
    <link href="/css/github.css" rel="stylesheet" />
    
    <!--<link href="http://getbootstrap.com/assets/css/docs.min.css" rel="stylesheet">-->
  </head>
  <body>
      <nav class="navbar navbar-default navbar-static-top" role="navigation">
          <div class="container">
              <div class="navbar-header">
                  <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                     <span class="sr-only">Toggle navigation</span>
                     <span class="icon-bar"></span>
                     <span class="icon-bar"></span>
                     <span class="icon-bar"></span>
                  </button> 
                  <a class="navbar-brand" href="/">
                     <img src='/images/logo.svg' style="width:30px;" />
                     Pyodec
                  </a>
              </div>
              <!-- nav content and stuff... -->
              <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                  <ul class="nav navbar-nav">
                    <li><a href="/about/">About</a></li>
                    <li><a href="/docs/">Documentation</a></li>
                    <li><a href="/formats/">File Types</a></li>
                  </ul>
              </div>
          </div>
          
      </nav>
      <div class="container">
        <div class="row" id="ref_contents">
            <div class="col-md-2" id="ref"></div>
            <div class="col-md-10 col-md-push-2" role="main">
                <h1>Pyodec Documentation</h1>
                <p class="lead">
                    Welcome to Pyodec. This is the reference to the library of
                    core resources and techniques within the package.
                </p>
                <h1>Getting Started</h1>
                <p class="lead">
                    How to hit the ground running with pyodec. 
                </p>
                
                
                <h2>Installation</h2>
                <p>Download a distribution, or clone a version of the repo from Github, and 
                    execute the setup script in the traditional fashion.
                </p>
                <pre><code>$ python setup.py install</code></pre>
                <p>Append <code>--user</code> to install the package only for the local user.</p>
                <p>This is for Linux/Unix installations, and will make <code>pyodec</code> available
                    for import in locally run python executables. To <b>update</b>, simply
                    download a newer version of the code, (ie a new release) and execute
                    the update script as well with the same command.
                </p>
                <p>Pyodec may be added to <code>pypi</code> some day, but at this time
                    it must be installed manually</p>
                    
                    
                    
                <h3>Dependencies</h3>
                <p>
                    The basic modules of pyodec currently require only Python 2.7 or greater
                    (this library is not currently written in python 3), and NumPy. 
                    However, certain decoders may leverage other libraries, particularly
                    certain types of binary file decoders. Those dependencies will be
                    exposed when importing/executing the specific decoder module.
                </p>
                <div class="panel panel-info">
                    <div class="panel-heading">
                        <h4 class="panel-title">Future dependencies</h4>
                    </div>
                    <div class="panel-body">
                        <p>Current dependencies may not reflect installation 
                            requirements in the future.</p>

                    </div>
                </div>
                
                
                <h2>Decoding with Pyodec</h2>
                <p class="lead">
                    Pyodec offers two ways to access the <code>decode</code> method
                    for any specific file decoder. One is based on the core
                    library, where you pass the name of the decoder to use, and the 
                    <code>decode</code> method is returned. Alternatively you can
                    utilize the strucutre of the Pyodec package, and directly import
                    the decoder module, to access its <code>decode</code> method.
                </p>
                <h3>Accessing the decoder</h3>
                <p>
                    Pyodec is structured where decoders are stored in a 
                    module called <code>files</code>. To access a decoder, say
                    <code>vaisalaCl31msg2</code>, you could directly access it with
                    
                    
                </p>
                <pre><code>import pyodec.files.vaisalaCl31msg2 as decoder
>>> data = decoder.decode(src)</code></pre>
                <p>
                    so the <code>decode</code> method is an available method within
                    the named decoder module. This decoder, in return, is an instantiated
                    member of the decoder class contained within the module, which inherits the 
                    core <code>FileDecoder</code> methods, along with some decoder
                    metadata.
                </p>
                <p>Every properly constructed decoder will have a <code>decoder</code> attribute, which
                    is executable. There are several other variables within a decoder
                    module, one of which being the decoder's class, but you will have to
                    look at the docs for that specific decoder to work with those, as their names
                    are not fixed.
                </p>
                <h4>Using simple decoder access</h4>
                <p>
                    Another way to access a decoder is to import and call 
                    <code>pydec.decode</code>, which is a compressed function
                    which will load and exectue the decoder you want, when passed as a
                    string argument. Passing a decoder is required for this method.
                    Here is an example of using it to decode <code>src</code> as above.
                </p>
                <pre><code>import pyodec
>>> pyodec.decode(src, decoder='vaisalaCl31msg2')</code></pre>
                <p>
                    This slightly simplifies the importing process, but to customize
                    how your code uses a decoder, it is necessary to
                </p>
                <h3>Running a decoder</h3>
                <p>
                    There are two ways to decode, first, can decode as a procedural
                    process, where an entire file or dataset is decoded, and the 
                    output is returned. Alternatively you can run the decoder
                    as a generator, (assuming the returned data can be grouped in
                    some fashion), where you can control how many values are returned
                    per iteration. 
                </p>
                <h4>Iterative decoding</h4>
                <p class="text-warning">
                    <span class="label label-warning">Warning</span> 
                    Pyodec currently <em>only</em> returns an iterator object.
                </p>
                <p>
                    Assuming your data file will produce groups of data (like 
                    such as a collection of obseravations), a decoder can run
                    in a for loop, as a generator, returning a list of sets
                    every N sets (N defaults to 1000). This is Pyodec's default 
                    behavior. For data files which are not broken into 
                    discrete observations, or in some way do not fit this data
                    model, all the data will be returned at once, via the generator.
                </p>
                <pre><code>for data in pyodec.decode(src, 'decoderName', limit=1000):
    # do something with decoded collection of data points

#or

import pyodec.files.decoderName
for data in pyodec.files.decoderName.decode(src, limit=1000):
    # do an equivalent something wit the returned data</code></pre>    
                <p>
                    
                    The <code>limit</code> argument is optional.
                    When a data file is finished, and there are &lt; N sets int the 
                    dataset, they are yielded, so no data are missed.
                </p>
                <h4>Sequential decoding</h4>
                <p>
                    As a wrapper around the generator function, you can pass the 
                    argument <code>generator=False</code>, which will then execute
                    the generator internally, and return a single set of values. 
                   
               </p>
               <pre><code>data = pyodec.decode(src, 'decoderName', generator=False)</code></pre>
               
               <p>
                   And that is how you use pyodec, should you have an existing decoder
                   available for your data file (and how you use it once you have built
                   a decoder for your file)
               </p>
               <h3>Building a decoder</h3>
               <p>
                   Well, this isn't really a "getting started" scenario, unfortunately. 
                   Read further down in the docs for the guide on developing a decoder.
               </p>
               
               
               <h1>Protocols and rules</h1>
               <span class="label label-info">Under Development</span>
               <p class="lead">
                   Though Pyodec is really a loosely connected set of independently
                   written codes, it is important for the data model API to 
                   be compatible between different decoders. The goal of these
                   rules will be to allow a single piece of code to take a diverse
                   set of files (knowing their decoders), and both decode them and
                   look at the data with the same code.
               </p>
               <p>
                   Basic python rules for internal consistency, variable and method
                   naming, etc. should be followed.
               </p>
               <p>
                   This is python, so there are no private methods. Rewrite/reallocate
                   any internal method as you please, but when doing so please try
                   to follow these usage guidelines. If you find a better way to 
                   do the central <code>decode</code> method, then share it!
               </p>
               <h2>Input &amp; client interfacing</h2>
               <p>
                   Decoders should accept <b>file path string</b>, <b>file object</b>,
                   and (where possible) <b>string</b> inputs to the decoder method as the 
                   first argument.
                   
               </p>
               <p>
                   At a minimum, a decoder class should contain a <code>decode</code>
                   method which can be run conforming to these input and interface
                    protocols.
               </p>
               <p>
                   Decoders should produce a generator object, (usually using <code>yield</code>),
                   and should allow the keyword argument <code>generator</code> control
                   whether a generator or list is returned. <code>generator</code> should
                   default to <code>True</code>.
               </p>
               <br />
               <!-- extra keyword arguments -->
               <h4>Required <code>.decode()</code> keyword arguments</h4>
               <table class="table">
                   <thead>
                       <tr><th>Argument</th><th>Type</th><th>Purpose</th></tr>
                   </thead>
                   <tbody>
                       <tr>
                           <td><code>limit</code></td>
                           <td>int</td>
                           <td>Number of discrete data results to accumulate before yielding</td>
                       </tr>
                       <tr>
                           <td><code>generator</code></td>
                           <td>bool</td>
                           <td>
                               Produce a generator based on <code>limit</code>, 
                               or a single set of values representing the entire dataset.
                               <br />
                               <span class="label label-danger">Warning</span> Not all
                               decoders at this time implement this protocol, and simply
                               return generators at all times.
                           </td>
                       </tr>
                   </tbody>
               </table>
               <p><em>
                   These input requirements will evolve and expand over time 
                   (such as a requirement to handle certain keyword arguments properly)
               </em></p>
               <h2>Data output and returning</h2>
               <p>
                   The possible range of outputs is far more diverse than the possible
                   inputs, however there are a few goals that can be shared.
               </p>
               <h4>Discrete observations are collected in a list</h4>
               <p>Not the other way around. <b>This is less efficient with memory</b>, but
                   it is conceptually much simpler, and allows the second rule to
                   actually work. </p>
               <div class="text-center">
                   <pre><code>yield [{'var1':12,'var2':[4,4,4]}, {'var1':12,'var2':[5,5,5]}, ... ]</code></pre>
                   not
                   <pre><code>yield {'var1':[12,12,14], 'var2': [[4,4,4],[5,5,5],[6,7,4]]}</code></pre>
                   
               </div>
               <div class="alert alert-info" role="alert">
                   <div class="fa fa-info-circle"></div> <b>Note:</b> acutual observations should be lists or numpy recarrays, 
                   not dictionaries. Variables, column names, or their equivalents
                   are handled in the metadata portion of the protocol.
               </div>
               
               <h4>Iterative and sequential output are the same structure</h4>
               <p>
                   Simply, you interact with a returned list of values in the same
                   manner, whether you receive them from a <code>yield</code> or a
                   <code>return</code>.
               </p>
               <h2>Variable and data descriptions</h2>
               <p>
                   This is the least-defined rule of the library. Many data files are 
                   self-describing in some manner, and it is essential to extract this
                   metadata from files. However, in the observation-based return schema
                   described above, metadata would not necessarily be included as 
                   discrete sets of data. The current best-practice for handling metadata --
                   and a method built into Pyodec -- is to add variable names, and descriptions
                   to the decoder itself. 
               </p>
               <p>
                   Pyodec surfaces two class objects which can, and should, be used
                   for logging and sharing the variables within the decoded file. 
                   These are                    
               </p>
               <table class="table">
                   <thead><tr><th>Class</th><th>Purpose</th></tr></thead>
                   <tbody>
                       <tr>
                           <td><code>VariableList</code></td>
                           <td>
                               The description of the values that are stored in
                               each discrere observation.
                           </td>
                       </tr>
                       <tr>
                           <td><code>FixedVariableList</code></td>
                           <td>
                               Each variable which is a consant throughout the dataset, 
                               such as <code>height</code> in a profiler dataset.
                           </td>
                       </tr>
                   </tbody>
               </table>
               <p>
                   These classes/objects contain the column/variable name, the 
                   ideal numpy dtype for that column, a shape vector, a long name, 
                   and a unit. Long name can be omitted, but really shouldn't.
                   As it is currently designed, varaibles must be appended to the 
                   list in the order which they will be found in the dataset. 
                   <code>FixedVariableList</code> objects contain the data within them,
                   such as the height values, or elevation angles, so order is 
                   unimportant.
                  
               </p>
               <p>
                   Usually you will specify these values manually in the decoder
                   code. But it is certainly possible to do it programatically, 
                   but the information can be hard to acquire. When you instantiate
                   your decoder class, you can also inherit the <code>VariableList</code>
                   and/or <code>FixedVariableList</code> from another class. 
               </p>
               <p>
                   By using these two objects, and appending them to the decoder 
                   class on instantiation will provide the client user with several
                   ways to access metadata. 
                   
                   
               </p>
               <p>
                   Each returned decoder instance will have methods <code>.getvars()</code>,
                   <code>.get_fixed_vars()</code>, and <code>.get_dtype()</code> in addition
                   to the instance attributes <code>.vars</code> and <code>.fixed_vars</code>.
                   They function as follows
               </p>
               <table class="table">
                   <thead><tr><th>Method</th><th>Function</th></tr></thead>
                   <tbody>
                       <tr>
                           <td><code>.getvars()</code></td>
                           <td>
                               Return a list of dictionaries containing name, dtype and shape info.
                           </td>
                       </tr>
                       <tr>
                           <td><code>.get_fixed_vars()</code></td>
                           <td>
                               Return similar info to <code>.getvars()</code>, but includes the 
                               actual data files as well.
                           </td>
                       </tr>
                       <tr>
                           <td><code>.get_dtype()</code></td>
                           <td>
                               Return a valud Numpy-recarray dtype description, such that you could say
                               <pre><code>import pyodec.files.myDecoder as dec
import numpy as np
for data in dec.decode(src):
    data0_in_numpy = np.array(data[0], dtype = dec.get_dtype())</code></pre>
                           </td>
                       </tr>
                       <tr>
                           <td><code>.vars</code></td>
                           <td>An attribute that contains the original <code>VariableList</code> object, and all its information/methods</td>
                       </tr>
                       <tr>
                           <td><code>.fixed_vars</code></td>
                           <td>An attribute that contains the original <code>FixedVariableList</code> object, and all its information/methods</td>
                       </tr>
                   </tbody>
               </table>
               <p><i>
                   As noted, these variable/metadata requirements are not set in
                   stone, and will likely change through development with
                   other users. Obviously backwards compatibility will become
                   an issue pretty quickly, however.
               </i></p>
               <h1>Core objects and methods</h1>
               
               
               <h1>Writing a decoder</h1> 
            </div> <!-- documentation div -->
            
        </div>
    </div>
    
    <footer>
        <div class="container">
            <p>
                &copy; 2014 MesoWest &amp; The University of Utah -
                <a href="/legal/">Legal</a> - <a href="/site/">About this site</a>
            </p>
        </div>
        
    </footer>

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="/bs/js/bootstrap.min.js"></script>
    <script src="/js/scroll.js"></script> 
    <script src="/js/highlight.pack.js"></script>
    <script type="text/javascript">
        hljs.initHighlightingOnLoad();
    </script>
  </body>
</html>